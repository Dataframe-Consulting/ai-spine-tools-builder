#!/usr/bin/env node

/**
 * Custom TypeScript declaration generator for ai-spine-tools-testing
 * This script creates index.d.ts to work around superagent type conflicts
 */

const fs = require('fs');
const path = require('path');

const typeDefinition = `// Type definitions for @ai-spine/tools-testing
// Auto-generated by build process

export * from '@ai-spine/tools-core';

// Test client interfaces
export interface TestClientOptions {
  baseUrl?: string;
  timeout?: number;
  retries?: number;
}

export interface TestExecutionResult {
  success: boolean;
  data?: any;
  error?: string;
  timing?: {
    duration: number;
    startTime: number;
    endTime: number;
  };
}

export interface PerformanceMetrics {
  totalRequests: number;
  successfulRequests: number;
  failedRequests: number;
  averageResponseTime: number;
  minResponseTime: number;
  maxResponseTime: number;
  requestsPerSecond: number;
}

export interface LoadTestOptions {
  concurrent?: number;
  duration?: number;
  requests?: number;
}

export interface LoadTestResult {
  metrics: PerformanceMetrics;
  scenarios: ScenarioResult[];
}

export interface ScenarioResult {
  name: string;
  success: boolean;
  duration: number;
  error?: string;
}

export interface ToolValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
}

export interface RequestEvent {
  type: 'request';
  timestamp: number;
  data: any;
}

export interface ResponseEvent {
  type: 'response';
  timestamp: number;
  data: any;
  status: number;
}

export interface ErrorEvent {
  type: 'error';
  timestamp: number;
  error: string;
}

// Test client class
export declare class AISpineTestClient {
  constructor(options?: TestClientOptions);
  execute(toolId: string, input: any, config?: any): Promise<TestExecutionResult>;
  health(toolId?: string): Promise<any>;
  schema(toolId?: string): Promise<any>;
  loadTest(toolId: string, input: any, options?: LoadTestOptions): Promise<LoadTestResult>;
}

// Test helper interfaces
export interface TestToolOptions {
  baseUrl?: string;
  timeout?: number;
  validateSchema?: boolean;
}

export interface TestDataGenerationOptions {
  count?: number;
  type?: string;
  includeEdgeCases?: boolean;
}

export interface TestScenariosOptions {
  includeBoundaryTests?: boolean;
  includeErrorCases?: boolean;
  includePerformanceTests?: boolean;
}

export interface TestScenario {
  name: string;
  input: any;
  config?: any;
  expectedStatus: 'success' | 'error';
  description?: string;
}

export type InvalidDataType = 'null' | 'undefined' | 'wrong_type' | 'invalid_format' | 'out_of_bounds';

// Test helper functions
export declare function testTool(
  toolUrl: string,
  input: any,
  config?: any,
  options?: TestToolOptions
): Promise<TestExecutionResult>;

export declare function testToolDirect(
  toolDefinition: any,
  input: any,
  config?: any
): Promise<TestExecutionResult>;

export declare function testToolHealth(
  toolUrl: string,
  options?: TestToolOptions
): Promise<any>;

export declare function generateTestData(
  schema: any,
  options?: TestDataGenerationOptions
): any[];

export declare function generateInvalidTestData(
  schema: any,
  invalidType?: InvalidDataType
): any;

export declare function generateConfigTestData(
  configSchema: any,
  options?: TestDataGenerationOptions
): any;

export declare function createTestScenarios(
  toolSchema: any,
  options?: TestScenariosOptions
): TestScenario[];

export declare function validateToolResponse(
  response: any,
  expectedSchema?: any
): ToolValidationResult;

export declare const toolAssertions: {
  isSuccess: (result: TestExecutionResult) => boolean;
  hasError: (result: TestExecutionResult) => boolean;
  hasData: (result: TestExecutionResult) => boolean;
  responseTimeUnder: (result: TestExecutionResult, maxMs: number) => boolean;
};

// Advanced testing utilities
export declare class MockManager {
  constructor();
  mock(moduleName: string, implementation: any): void;
  restore(moduleName?: string): void;
  restoreAll(): void;
}

export declare class PerformanceTester {
  constructor(options?: any);
  measureExecution<T>(fn: () => Promise<T>): Promise<{ result: T; metrics: PerformanceMetrics }>;
  benchmark(name: string, fn: () => Promise<any>, iterations?: number): Promise<PerformanceMetrics>;
}

export declare class TestServer {
  constructor(options?: any);
  start(port?: number): Promise<void>;
  stop(): Promise<void>;
  addRoute(method: string, path: string, handler: Function): void;
}

export declare class TestSuiteRunner {
  constructor(options?: any);
  addTest(name: string, testFn: () => Promise<any>): void;
  run(): Promise<{ passed: number; failed: number; results: any[] }>;
}
`;

const distPath = path.join(__dirname, '..', 'dist');
const typesPath = path.join(distPath, 'index.d.ts');

// Ensure dist directory exists
if (!fs.existsSync(distPath)) {
  fs.mkdirSync(distPath, { recursive: true });
}

// Write the type definition file
fs.writeFileSync(typesPath, typeDefinition, 'utf8');

console.log('âœ… Generated TypeScript declarations at dist/index.d.ts');
